---
title: "Introduction to the mondate Package"
author: "Dan Murphy"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
#output: rmarkdown::word_document
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Base R provides two broad date/time classes,
`POSIXt` and `Date`.
Objects of these classes
mark a day with the instant of
time that begins the day. 
This conforms with 
internationally recognized 
standards^[Refer to http://www.iso.org/iso/home/standards/iso8601.htm
or
https://en.wikipedia.org/wiki/ISO_8601].
In contrast, 
`mondate` objects represent a day as at the instant of time that ends the day.
This "close of business" perspective can be useful, 
as when modeling accounting as-of dates,
extends to "month close" and "year close,"
and enables the other major purpose of the `mondate` package -- 
measuring elapsed time in 
units of "months", and therefore also "years".

The four major benefits of the mondate package are:

1. Date Aging
1. Date Formatting
1. Date Sequencing
1. Date Cutting

## Date Aging

The "age" of an event plays many important roles in business use cases.
By default, `Date` objects are measured in units of "days" and `POSIXt` objects in 
units of "seconds".
But sometimes it is more convenient to measure elapsed time in units of 
"months" or "years".
This is where `mondate` comes in.

#### Example 1 
If my "birth event" took place on February 29, 1996
then my age on February 28, 2006 was 10:

```{r birthday}
require(mondate)
YearsBetween("1996-02-29", "2006-02-28")
```
or in the US
```{r}
YearsBetween("2/29/1996", "2/28/2006")
```
and
```{r}
MonthsBetween("2/29/1996", "2/28/2006")
```
which also results when subtracting two `mondate`s
```{r}
m1 <- mondate.ymd(1996, 2)
m2 <- mondate.ymd(2006, 2)
m2 - m1
```

#### Example 2
Suppose ABC Company invoices a customer in late October 2015
and has a policy of recognizing that invoice to have been sent
on the 1st of November.
This code calculates the ages of that invoice in months 
as of the end of 2015 and 2016:

```{r}
invoiceDate = as.Date("2015-11-01")
ages <- mondate.ymd(2015:2016) - invoiceDate
print(ages)
```

#### Example 3
The last example in this section is actuarial in nature.
Suppose ABC Company records the date of insured losses using the variable name
DateOfLoss. 
Here are 10 random dates after the end of 2010:
```{r}
# generate 10 random dates after 2010
set.seed(1)
z <- rexp(10, .1)
DateOfLoss <- as.Date(mondate.ymd(2010) + z)
print(DateOfLoss)
```
Here are the four quarter-ends in 2013:
```{r}
# Quarter-ends in 2013
QE <- mondate.ymd(2013, 3 * 1:4, displayFormat = "%Y%m")
names(QE) <- QE
print(QE)
```
(The 'displayFormat' argument will be explained in the next section.
"names" were assigned to enable the matrix header labels below.)
And here are the ages of the 10 losses as of each quarter end:
```{r}
# a matrix of ages in units of months
Ages <- sapply(QE, `-` , DateOfLoss)
# code "not available" ages corresponding to evaluation dates prior to Date of Loss
# (one instance)
Ages[Ages <= 0] <- NA
print(Ages)
```
The actuarial "accident year" concept can be created as follows:
```{r}
# Accident year age
AccidentYear <- year(DateOfLoss)
aybegin <- sort(unique(as.Date(mondate.ymd(AccidentYear, 1, 1))))
print(sapply(QE, `-`, aybegin))
```

See the "Date Cutting" section below for a
more elegant way to do the last calculation.

### Date Arithmetic

`mondate`s can act arithmetically in (almost always) the same way
their underlying `numeric` can 
act.^[The underlying numeric measures the number of months since 
the close of business 1999-12-31 (".mondate.origin").]
In particular, 
the magnitude of the interval between two dates in units of months
is measured, of course, using subtraction:
```{r}
mondate("12/31/2015") - mondate("12/31/2014")
mondate("12/31/2015") - as.Date("2015-01-01")
```
Why do the two calculations result in the same value?
The answer is that the two objects,
as.Date("2015-01-01") and mondate("12/31/2014")
*represent the same instant in time*
separating the moments in 2014 from the moments in 2015.
Those two instants are by convention one year apart.

## Date Formatting

`mondate` enables dates to be read and displayed in more than one format.
The default formats currently recognized are

* US format: "%m/%d/%Y" or "%m-%d-%Y"
* EU format: "%Y-%m-%d" or "%Y/%m/%d"

in that order,
depending on your value of `Sys.getlocale("LC_TIME")`.
The order can be changed and new formats added using `base::options`
for display ("writing") and 
`set.mondate.displayFormats` for "reading".

### "writing": dynamic format display

#### Example 4
This vignette is being written in the US, 
so today's date will be represented using the first format above by default ...

```{r}
mondate(Sys.Date())
```

... but that default can be changed to the
international standard format^[ibid.]
"YYYY-MM-DD" using
`base::options` and the name
"mondate.default.displayFormat" as follows

```{r}
options(mondate.default.displayFormat = "%Y-%m-%d")
mondate(Sys.Date())
```

#### Example 5 
French users may choose the format "dd/mm/YYYY" as follows:

```{r}
options(mondate.default.displayFormat = "%d/%m/%Y")
mondate(Sys.Date())
```

Note: 
these examples modified the default display format
for **all** mondates in the R session.
To set the display format for **just one** instance of a mondate object,
use the `displayFormat` argument during the object's creation.

#### Example 6
Here we create the first 6 month-ends of 2015
to be displayed in the French format above
despite the fact that the default format is changed to the ISO standard:

```{r}
options(mondate.default.displayFormat = "%Y-%m-%d")
mondate(Sys.Date())
m <- mondate.ymd(2015, 1:6, displayFormat = "%d/%m/%Y")
print(m)
```
```{r echo=FALSE, message=FALSE}
options(mondate.displayFormat = NULL)
```
```{r}

```

More creative formats can be used, 
as for instance
to display just the year and month,
as was done in "Example 3" above.
```{r echo=FALSE}
options(mondate.default.displayFormat = NULL)
```

### "reading": dynamic format detection

As mentioned above,
the `mondate` package is pre-loaded with four formats for detecting dates

1. US format a: "%m/%d/%Y"
2. US format b: "%m-%d-%Y"
3. EU format a: "%Y-%m-%d"
4. EU format b: "%Y/%m/%d"

To inform `mondate` of another format for converting character to date,
use `set.mondate.displayFormats`.
This function sets the `options` value of "mondate.displayFormats"
to the value(s) of your choice.

#### Example 7
To add the French format "dd/mm/yyyy" to the *head* of the
current list of detectable formats --
thereby setting that format to priority 1 status --
use the following code:

```{r}
set.mondate.displayFormats(c("%d/%m/%Y", 
                             get.mondate.displayFormats()), 
                           clear = TRUE)
```
(This example is given in ?set.mondate.displayFormats.)
Contining, 
suppose dates in a spreadsheet are saved to a csv file in France
and the `read.csv` function results in this data.frame:
```{r}
data <- data.frame(
  cbind(Invoice=c("A", "B", "C"),
        datechar = c("28/11/2015", "29/11/2015", "30/11/2015")))
print(data)
```
Then the character dates can be converted automatically to `Date` objects
via `mondate` as follows
```{r}
data$InvoiceDate <- as.Date(mondate(data$datechar))
print(data)
```

For more information on the codes to use when formatting dates,
see the R help page for the `strptime` function.
To add addtional defaults according to your value of
`Sys.getlocale("LC_TIME")`,
contact the 
author^[chiefmurphy at gmail].
(All are welcome to visit the package's public repository at
https://github.com/chiefmurph/mondate.)

## Date Sequencing

Sequences of dates in units of days or multiples of days
or weeks is easily accomplished using the base R's `Date` class:  
```{r} 
seq(as.Date("2015-11-01"), by = "day", length.out = 5)
```
Month-sequences can similarly be generated with `Date`s, and work well
for most dates.
The exception can occur for dates near the end of the month.
Compare, for example, the two sequences below,
the first starting from the first day of January,
the second from the last day of January:
```{r}
seq(as.Date("2015-01-01"), by = "month", length.out = 5)
seq(as.Date("2015-01-31"), by = "month", length.out = 5)
```
All dates in the first sequence are the first days of the month,
but some dates in the second sequence "leak" into subsequent months.
Indeed this is is well documented in the help for `seq.POSIXt`:

>Using "month" first advances the month without changing the day: if this results in an invalid day of the month, it is counted forward into the next month

The mondate package avoids this 
shortcoming.^["Under the hood", `mondate` represent dates 
relative to the 
percent of the month that has transpired by the close of business that day.]

#### Example 8
Sequences of month ends can be accomplished in various "mondate" ways.
Here are two:
```{r}
seq(mondate("2015-01-31"), by = "month", length.out = 5)
mondate.ymd(2015, 1:5)
```
Note that the display format in the first sequence inherits from the
format of the character representation of the beginning date.
The display format in the second sequence is a function of the 
author's locale (see "Date Formatting" section above).
Also note that each of the objects generated above are of class "mondate".

### seqmondate
It might be more convenient to be able to generate month sequences from `Date` objects
without having to resort to a `mondate` "transitional" object as above
**and result in an object of class "Date".**
That is the purpose of the `seqmondate` method, 
which works on a variety of classes.
By default, 'by = "month"' is assumed.

#### Example 9

This example repeats Example 7, 
omits the 'by' argument and shortens the name of the 'length.out' argument.
Note that
the second sequence consists of all month-ends.
Also note that the class of the resulting object is the same class
as the object being operated on.
```{r}
seqmondate(as.Date("2015-01-01"), length = 5)
seqmondate(as.Date("2015-01-31"), length = 5)
class(seqmondate(as.Date("2015-01-31"), length = 5))
class(seqmondate(as.POSIXlt("2015-01-31"), length = 5))
```

#### Example 10: Year-ends
Here are two ways to generate sequences of year-end dates.
The first uses seqmondate as above.
The second uses the `mondate.ymd` function, 
specifying only the first argument ('year').
```{r}
seqmondate("2010-12-31", by = "year", length = 6)
mondate.ymd(2010:2015)
```

## Date Cutting

>Sidebar on `cut.default`  
A `cut` of a `numeric` 'x' is a collection of (half-open,half-closed]
intervals that "cover" 'x'.
By "cover" is meant that every value in 'x' is contained in some 
interval^[and thus not an "open cover" in a topological sense],
with the exception that the minimum value of 'x' is excluded --
unless the 'include.lowest' argument is explicitly set to `TRUE`.
A 'cut' in R is represented by a `factor`.
`cut.default` beautifully enunciates
the intervals by clearly identifying their borders
in the labels of the cut's levels.

A `cut` of a set of dates 'x' by "months" can be thought of as
a collection of contiguous months such that every date in x is contained in
some month.
This correspondence between a date and its neighboring members in its 'cut'
can be mined in a statistical analysis of events occurring in similar time periods.

`cut` has a method that works on `mondate`s when the 'breaks' argument is

* `numeric` and so represents 
the borders between intervals, or
* `character` and so identifies that the cover is to be a set of
day-, week-, month-, year-, or 
quarter-intervals.

First we will define some cuts.
Then we will see how one might use a `cut`.

####Example 11
The following two commands work identically,
only the displays of the results differ:
```{r}
cut(seq(from = 180.5, to = 185.5, by = .5), breaks = 180:186)
cut(seq(from = mondate(180.5), to = mondate(185.5), by = .5), breaks = 180:186)
```

In the monthly intervals that cut(x) above, 
if one were to label the interval with one of the endpoints,
it would be natural to choose the closed endpoint.
That is the 'mondate' convention when 'breaks' is `character`.
That bears repeating:

>The 'mondate' convention is to label a character cut of a set of dates
with the **closed endpoint** defining each interval.
As with `cut.default`, the closed endpoint is determined by
the argument 'right':
when `TRUE` the right endpoint is closed;
when `FALSE` the left endpoint is closed.

>Furthermore,
when 'breaks' is `character` (e.g., "months")
the closed endpoint becomes the label for the interval.

####Example 12

The following two commands generate the same result
The first explicitly sets the break points as the 
month-ends beginning 2014-12-31 and ending six months later.
The second implicitly sets the same break points.
```{r}
cut(seq(mondate("2015-01-15"), mondate("2015-06-15"), by = .5), 
    breaks = mondate.ymd(2014) + 0:6)
cut(seq(mondate("2015-01-15"), mondate("2015-06-15"), by = .5), breaks = "month",
    include.lowest = TRUE)
```
In the case that breaks is `character` it is unfortunate to have to 
set include.lowest opposite its default.
(Excluding the minimum value of 'x' would be somewhat "random" given
that other values of 'x' are probably in the same time interval.)

`include.lowest` is not the only argument that can be counterintuitive
when it comes to cutting dates.
Probably the most troubling default is `right = TRUE` because it violates 
the basic principle that `Date` objects begin on,
and are synonymous with,
the instant beginning the day,
i.e., the left endpoint.

For those and other reasons,
a `cutmondate` method was written to work on `Date`, `mondate`, and other objects
with arguments that are more appropriate for their class.
Other arguments were added, which we will see in due course.

We now turn our attention to the `cutmondate` methods.

### cutmondate

The 'cutmondate' collection of methods are most effective when 
'breaks' defines a cover in terms of months or multiple months.
When the object being cut is a `Date` or `POSIXt`,
the breakpoints are assumed to begin the period.
Therefore, right = FALSE by default. 
This results in a labeling of the levels according to the 
first date in the period.

####Example 13

Here we regenerate the dates in Example 3, and cut them into month intervals.
```{r}
set.seed(1)
z <- rexp(10, .1)
monDOL <- mondate.ymd(2010) + z
DateOfLoss <- as.Date(monDOL)
print(DateOfLoss)
cutmondate(DateOfLoss)
```
The "28 Levels" says that it takes 28 contiguous months to cover 'DateOfLoss'.
Note that the levels are labeled with the first day of each month,
starting with February 1, 2011 and ending with May 1, 2013.
In this case, 
since class(DateOfLoss) equals "Date"
cutmondate knows that the more natural value for 'right' is `FALSE`.

To label the levels with the last day of the month, 
specify right = TRUE when the object is a `Date`.
Here the levels are labeled with the lasst day of each month,
starting with February 28, 2011 and ending with May 31, 2013.
In the second case the object is a `mondate`, so right = `TRUE` by default
and the date is displayed the default format of the author's locale.
```{r}
cutmondate(DateOfLoss, right = TRUE)
cutmondate(monDOL)
```

Before tackling the last example,
it is important to point out three additional arguments for `cut.mondate`
(and therefore `cutmondate`)
that do not appear in `cut.default` or `cut.Date`:

* startmonth
* startyear
* attr.breaks = FALSE

See the help for `cut.mondate` for details behind these arguments. 
The only one we will discuss in this intro vignette is 'startmonth'.

### Fiscal Years

The 'startmonth' argument is important when you want to model fiscal years.

####Example 14

ABC Company's fiscal year is July 1 through June 30. 
The dates of loss in the previous examples can be cut into fiscal years
by setting startmonth = 7.
The fiscal year cover will be three years long. 
In the first case below the FYs are labeled by the first day of the fiscal year;
in the second case, by the last day.
```{r}
cutmondate(DateOfLoss, breaks = "year", startmonth = 7)
cutmondate(mondate(DateOfLoss), breaks = "year", startmonth = 7)
```
Continuing, suppose ABC Company conventually refers to a fiscal year
by the first calendar year.
The level labels can be set automatically as follows:
```{r}
cutmondate(mondate(DateOfLoss, displayFormat = "%Y"), 
           breaks = "year", right = FALSE, startmonth = 7)
```


####Example 15

ABC Company records loss amounts associated with the dates of loss at 
regular intervals. 
Suppose the amounts as of 2016-06-30 are
```{r}
(LossAmount <- round(rnorm(10, 1000, 100), -1))
```
ABC is interested in calculating the ages of those amounts as of the
end of the current fiscal year, June 30, 2016.
Those ages are easily calculated as follows.
Generate the Fiscal Year (FY) indicators as below, 
using "attr.breaks = TRUE".
This will return the break points as a attribute
that can be used in the date arithmetic.
```{r}
FY <- cutmondate(mondate(DateOfLoss, displayFormat = "%Y"), 
           breaks = "year", right = FALSE, startmonth = 7,
           attr.breaks = TRUE)
age <- mondate.ymd(2016, 6)- attr(FY, "breaks")[FY]
(data <- data.frame(DateOfLoss, LossAmount, FY, FYage = age))
```
^[R includes the units in FYage because 'age' above is a `difftime` object.]
In summary,

* "cutmondate" the set of dates using values for 'right' and 'startmonth'
as appropriate for the situation.
* Using `mondate(DateOfLoss)` is just one convenient way of abbreviating the factor levels.
* Set 'attr.breaks = TRUE' so breakpoints are available for arithmetic.
* Since FY is fundamentally an "index", `attr(FY, "breaks")[FY]` pulls out the 
left breakpoint corresponding to each DateOfLoss's value of FY
* The "age" results from subtraction from the `mondate` "as of" evaluation date
of interest.


## Thank you

Damien Laker
Gabor
R-Development team

